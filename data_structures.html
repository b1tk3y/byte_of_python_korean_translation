
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>자료구조 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 4.0.4">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="problem_solving.html" />
    
    
    <link rel="prev" href="modules.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="dedication.html">
            
                <a href="dedication.html">
            
                    
                    헌정
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="preface.html">
            
                <a href="preface.html">
            
                    
                    서문
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="about_python.html">
            
                <a href="about_python.html">
            
                    
                    파이썬에 대하여
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="installation.html">
            
                <a href="installation.html">
            
                    
                    설치
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="first_steps.html">
            
                <a href="first_steps.html">
            
                    
                    첫 걸음
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="basics.html">
            
                <a href="basics.html">
            
                    
                    기초
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="op_exp.html">
            
                <a href="op_exp.html">
            
                    
                    연산자와 수식
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="control_flow.html">
            
                <a href="control_flow.html">
            
                    
                    흐름 제어
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="functions.html">
            
                <a href="functions.html">
            
                    
                    함수
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="modules.html">
            
                <a href="modules.html">
            
                    
                    모듈
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.12" data-path="data_structures.html">
            
                <a href="data_structures.html">
            
                    
                    자료구조
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="problem_solving.html">
            
                <a href="problem_solving.html">
            
                    
                    실생활 문제 해결
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="oop.html">
            
                <a href="oop.html">
            
                    
                    객체 지향 프로그래밍
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="io.html">
            
                <a href="io.html">
            
                    
                    입력과 출력
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="exceptions.html">
            
                <a href="exceptions.html">
            
                    
                    예외 처리
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="stdlib.html">
            
                <a href="stdlib.html">
            
                    
                    표준 라이브러리
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="more.html">
            
                <a href="more.html">
            
                    
                    더 많은 것들
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.19" data-path="what_next.html">
            
                <a href="what_next.html">
            
                    
                    남은 과제
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.20" data-path="floss.html">
            
                <a href="floss.html">
            
                    
                    부록: FLOSS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.21" data-path="about.html">
            
                <a href="about.html">
            
                    
                    부록: 이 책에 대하여
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.22" data-path="revision_history.html">
            
                <a href="revision_history.html">
            
                    
                    부록: 과거로부터의 교훈
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.23" data-path="translations.html">
            
                <a href="translations.html">
            
                    
                    부록: 번역
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.24" data-path="translation_howto.html">
            
                <a href="translation_howto.html">
            
                    
                    부록: 번역 방법
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.25" data-path="feedback.html">
            
                <a href="feedback.html">
            
                    
                    피드백
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >자료구조</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="data-structures">자료구조 </h1>
<p>자료구조란 간단하게, 어떤 <em>자료</em>를 담는 <em>구조</em>를 말합니다. 다른 말로 하면, 서로 연관있는 어떤 자료들의 집합을 저장하는 데 사용됩니다.</p>
<p>파이썬에는 네 종류의 자료구조가 있는데, 각각 <em>리스트, 튜플, 사전(dictionary), 집합(set)</em> 입니다. 이제 앞으로 각각의 사용법에 대해 알아보고 또 각각이 얼마나 편리한지 알아보도록 하겠습니다.</p>
<h2 id="리스트">리스트</h2>
<p><code>리스트</code>란 순서대로 정리된 항목들을 담고 있는 자료 구조입니다. 즉, 리스트에는 항목의 <em>목록</em>을 저장할 수 있습니다. 이것은 쉽게 말하자면 장 보러 갈 때 적는 일종의 장바구니 목록 같은 것인데, 아마도 여러분은 각 품목들을 한줄씩 적는 데 익숙하시겠지만 리스트에서는 줄 대신 쉼표로 각 항목을 구분한다는 점이 다릅니다.</p>
<p>리스트를 정의할 때는 대괄호 [] 를 이용해서 파이썬에게 이것이 리스트를 의미한다는 것을 알려 줍니다. 한번 리스트를 만들어 두면 여기에 새로운 항목을 추가하거나 삭제할 수 있으며, 특정 항목이 존재하는지 검색할 수도 있습니다. 이 때 항목을 추가 및 삭제가 가능하다는 특징을 <em>비정적(mutable)</em>이라고 하며, 리스트는 비정적 자료구조의 한 예로 내부 항목을 변경할 수 있는 자료형입니다.</p>
<h2 id="객체와-클래스에-대한-간단한-소개">객체와 클래스에 대한 간단한 소개</h2>
<p>객체와 클래스에 대해서는 좀 더 나중에 다룰 예정이지만, 여기서 여러분이 리스트에 대해 좀 더 잘 이해하실 수 있도록 이에 대한 간단한 소개를 하도록 하겠습니다. 이들에 대해서는 <a href="oop.html#oop">뒤 챕터</a>에서 좀 더 자세하게 다루겠습니다.</p>
<p>리스트는 객체와 클래스가 사용된 한 예입니다. 변수 <code>i</code> 를 선언하고 예를 들어 <code>5</code> 라는 정수형 값을 할당해 주는 것은, <code>int</code> 라는 <em>클래스</em> (또는 <em>타입</em>) 의 <em>객체</em> (또는 <em>인스턴스</em>) <code>i</code> 를 만드는 것입니다. 이에 대해 좀 더 자세히 알아보려면 <code>help(int)</code> 를 읽어보시기 바랍니다.</p>
<p>클래스는 <em>메소드</em>를 가질 수 있는데, 여기서 메소드란 그 클래스 내에 정의된 고유의 내장 함수들을 말합니다. 또 이러한 내장 함수들은 클래스로 객체를 생성했을 때에야 비로소 사용할 수 있습니다. 예를 들어, 파이썬의 <code>list</code> 클래스에는 <code>append</code> 라는 메소드가 포함되어 있으며 이는 리스트의 마지막에 항목을 한 개 추가할 때 사용되는 메소드입니다. 즉 <code>mylist.append(&apos;an item&apos;)</code> 라 하면 리스트 <code>mylist</code> 의 마지막에 해당 문자열을 추가해 줍니다. 이 때 객체의 메소드에 접근할 때에도 마침표를 이용한다는 점을 기억하세요.</p>
<p>또 클래스는 <em>필드</em>를 가질 수 있는데 이것은 단순히 그 클래스 내에 정의된 변수들을 의미합니다. 메소드와 마찬가지로 이러한 변수들은 클래스로 객체를 생성했을 때에야 비로소 사용할 수 있습니다. 필드도 메소드와 마찬가지로 마침표를 이용하여 접근합니다. 예를 들면 <code>mylist.field</code> 와 같습니다.</p>
<p>예제 (<code>ds_using_list.py</code> 로 저장하세요):</p>
<pre><code class="lang-python"><span class="hljs-comment"># This is my shopping list</span>
shoplist = [<span class="hljs-string">&apos;apple&apos;</span>, <span class="hljs-string">&apos;mango&apos;</span>, <span class="hljs-string">&apos;carrot&apos;</span>, <span class="hljs-string">&apos;banana&apos;</span>]

<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;I have&apos;</span>, <span class="hljs-built_in">len</span>(shoplist), <span class="hljs-string">&apos;items to purchase.&apos;</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;These items are:&apos;</span>, end=<span class="hljs-string">&apos; &apos;</span>)
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> shoplist:
    <span class="hljs-built_in">print</span>(item, end=<span class="hljs-string">&apos; &apos;</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;\nI also have to buy rice.&apos;</span>)
shoplist.append(<span class="hljs-string">&apos;rice&apos;</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;My shopping list is now&apos;</span>, shoplist)

<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;I will sort my list now&apos;</span>)
shoplist.sort()
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Sorted shopping list is&apos;</span>, shoplist)

<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;The first item I will buy is&apos;</span>, shoplist[<span class="hljs-number">0</span>])
olditem = shoplist[<span class="hljs-number">0</span>]
<span class="hljs-keyword">del</span> shoplist[<span class="hljs-number">0</span>]
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;I bought the&apos;</span>, olditem)
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;My shopping list is now&apos;</span>, shoplist)
</code></pre>

<p>실행 결과:</p>
<pre><code>$ python ds_using_list.py
I have 4 items to purchase.
These items are: apple mango carrot banana
I also have to buy rice.
My shopping list is now [&apos;apple&apos;, &apos;mango&apos;, &apos;carrot&apos;, &apos;banana&apos;, &apos;rice&apos;]
I will sort my list now
Sorted shopping list is [&apos;apple&apos;, &apos;banana&apos;, &apos;carrot&apos;, &apos;mango&apos;, &apos;rice&apos;]
The first item I will buy is apple
I bought the apple
My shopping list is now [&apos;banana&apos;, &apos;carrot&apos;, &apos;mango&apos;, &apos;rice&apos;]
</code></pre>

<p><strong>동작 원리</strong></p>
<p>어떤 사람이 마트에 장 보러 갈 때 장바구니 목록을 변수 <code>shoplist</code> 에 담아 두었다고 합시다. 이 <code>shoplist</code> 에는 구매할 항목들의 이름들, 즉 문자열들이 담겨 있을 것이지만, 사실 리스트에는 <em>어떤 종류의 객체</em> 든지 담을 수 있어서 숫자도 담을 수 있고, 심지어는 리스트 안에 다른 리스트도 담을 수 있습니다.</p>
<p>여기서는 <code>for..in</code> 반복문을 사용하여 리스트 안에 담겨 있는 항목들을 하나씩 반복하여 읽어왔습니다. 이제쯤 되면 리스트는 열거형이라는 점을 알고 계셔야 합니다. <a href="#sequence">열거형</a>에 대해서는 뒤에 좀 더 자세히 다루겠습니다.</p>
<p>print 함수에 추가한 <code>end</code> 매개변수는 출력될 내용 뒤에 줄바꿈 기호 대신 공백을 출력하도록 지정해 준 것입니다.</p>
<p>다음으로, 앞서 설명했듯이 리스트 객체의 <code>append</code> 메소드를 이용해서 리스트에 항목을 한 개 추가합니다. 그리고, 추가된 항목이 제대로 추가되었는지 확인하기 위해 print 함수에 리스트를 넘겨 주어 리스트의 내용을 화면에 예쁘게 출력해 줍니다.</p>
<p>이제 리스트의 <code>sort</code> 메소드를 이용하여 리스트의 내용을 정렬해 줍니다. 여기서 이 메소드는 해당 리스트 자체를 변화시키며 수정된 리스트를 또 반환해주지 않는데 이 점을 이해하는 것이 중요합니다. <em>정적(immutable)</em> 인 문자열과 달리 리스트는 변화될 수 있는 성질을 지녔으며 이것을 <em>비정적(mutable)</em> 이라 합니다.</p>
<p>다음으로 물건을 구매한 뒤에는 장바구니 목록에서 해당 항목을 지워야 할 것입니다. 이 때 <code>del</code> 문을 사용하여 항목을 삭제합니다. 항목을 삭제할 때는 어떤 항목을 지울지 del 문에 알려 주면 리스트로부터 해당 항목이 삭제됩니다. 여기서는 <code>del shoplist[0]</code> 이라고 입력하여 첫 번째 항목을 삭제할 것임을 알려 주었습니다 (파이썬은 숫자를 0부터 센다는 점을 기억하시기 바랍니다).</p>
<p>리스트 객체가 갖고 있는 모든 메소드에 대해 알고 싶으시면, <code>help(list)</code> 를 입력해 보시기 바랍니다.</p>
<h2 id="튜플">튜플</h2>
<p>튜플은 여러 개의 객체를 모아 담는 데 사용됩니다. 튜플은 리스트와 비슷하지만, 리스트 클래스에 있는 여러가지 기능이 없습니다. 또 튜플은 수정이 불가능하며, 그래서 주로 문자열과 같이 <em>비정적</em>인 객체들을 담을 때 사용됩니다.</p>
<p>튜플은 괄호로 묶인 쉼표로 구분된 여러 개의 항목으로 정의되며, 괄호는 생략이 가능합니다.</p>
<p>튜플에 저장된 값들은 수정이 불가능하기 때문에, 단순히 값들의 목록을 저장해두고 쓸 때 주로 사용됩니다.</p>
<p>예제 (<code>ds_using_tuple.py</code> 로 저장하세요):</p>
<pre><code class="lang-python"><span class="hljs-comment"># I would recommend always using parentheses</span>
<span class="hljs-comment"># to indicate start and end of tuple</span>
<span class="hljs-comment"># even though parentheses are optional.</span>
<span class="hljs-comment"># Explicit is better than implicit.</span>
zoo = (<span class="hljs-string">&apos;python&apos;</span>, <span class="hljs-string">&apos;elephant&apos;</span>, <span class="hljs-string">&apos;penguin&apos;</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Number of animals in the zoo is&apos;</span>, <span class="hljs-built_in">len</span>(zoo))

new_zoo = <span class="hljs-string">&apos;monkey&apos;</span>, <span class="hljs-string">&apos;camel&apos;</span>, zoo    <span class="hljs-comment"># parentheses not required but are a good idea</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Number of cages in the new zoo is&apos;</span>, <span class="hljs-built_in">len</span>(new_zoo))
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;All animals in new zoo are&apos;</span>, new_zoo)
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Animals brought from old zoo are&apos;</span>, new_zoo[<span class="hljs-number">2</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Last animal brought from old zoo is&apos;</span>, new_zoo[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Number of animals in the new zoo is&apos;</span>,
      <span class="hljs-built_in">len</span>(new_zoo)-<span class="hljs-number">1</span>+<span class="hljs-built_in">len</span>(new_zoo[<span class="hljs-number">2</span>]))
</code></pre>

<p>실행 결과:</p>
<pre><code>$ python ds_using_tuple.py
Number of animals in the zoo is 3
Number of cages in the new zoo is 3
All animals in new zoo are (&apos;monkey&apos;, &apos;camel&apos;, (&apos;python&apos;, &apos;elephant&apos;, &apos;penguin&apos;))
Animals brought from old zoo are (&apos;python&apos;, &apos;elephant&apos;, &apos;penguin&apos;)
Last animal brought from old zoo is penguin
Number of animals in the new zoo is 5
</code></pre>

<p><strong>동작 원리</strong></p>
<p>변수 <code>zoo</code> 는 여러 항목들을 담고 있는 튜플입니다. 보시는 바와 같이 <code>len</code> 함수를 통해 튜플의 길이를 알아올 수 있습니다. 튜플 또한 <a href="#sequence">열거형</a> 의 한 예입니다.</p>
<p>이제 동물원(zoo) 안의 동물들을 새로운 동물원으로 옮겨야 한다고 해 봅시다. 이를 위해 <code>new_zoo</code> 튜플이라는 새로운 동물원을 만들어 주고, 새 동물원에 원래 있던 동물들에 추가로 기존의 동물원에 있던 동물들을 옮겨 왔습니다. 이 때 예제와 같이 튜플 안에 튜플을 담아도 튜플의 성질을 잃지 않습니다.</p>
<p>리스트에서 했던 것과 같이, 튜플 안에 있는 항목의 위치를 대괄호로 묶어 지정해주면 각 항목에 접근할 수 있습니다. 이를 <em>인덱싱</em> 연산자라고 부릅니다. <code>new_zoo</code> 의 세 번째 항목에 접근하려면 <code>new_zoo[2]</code> 와 같이 하며, 이 세 번째 항목은 튜플이므로 이것의 세 번째 항목에 접근하려면 <code>new_zoo[2][2]</code> 와 같이 합니다. 익숙해지면 쉽게 느껴질 것입니다.</p>
<blockquote>
<p><strong>빈 튜플과 한 개짜리 튜플</strong></p>
<p>빈 튜플은 괄호 안에 아무것도 적지 않고 <code>myempty = ()</code> 와 같이 생성할 수 있습니다. 그러나, 항목 한 개만 담고 있는 튜플을 정의할 때는 주의해야 합니다. 이 경우 첫 번째 항목의 뒤에 쉼표를 붙여 주어 파이썬에게 이것이 숫자 연산에 사용되는 괄호가 아니라 객체를 담는 튜플을 의미하는 것이라는 것을 구분할 수 있도록 단서를 주어야 합니다. 예를 들어, 항목 <code>2</code> 를 담고 있는 튜플을 정의하려면 <code>singleton = (2 , )</code> 와 같이 합니다.</p>
</blockquote>
<!-- -->
<blockquote>
<p><strong>펄 프로그래머를 위한 주석</strong></p>
<p>리스트 안의 리스트는 리스트의 성질을 잃지 않습니다. 리스트는 펄에서처럼 flatten 되지 않습니다. 이 성질은 튜플 안의 튜플이나 리스트 안의 튜플 혹은 튜프 안의 리스트의 경우 모두에 적용됩니다. 파이썬에서는 이들은 단지 다른 객체 안에 저장된 객체들일 뿐입니다.</p>
</blockquote>
<h2 id="사전-딕셔너리">사전 (딕셔너리)</h2>
<p>사전(딕셔너리)은 이를테면 전화번호부 같은 것인데, 누군가의 이름을 찾으면 그 사람의 주소와 연락처를 알 수 있는 것과 같습니다. 이 때 그 사람의 이름에 해당하는 것을 <em>키</em> 라 부르고, 주소와 연락처 등 세부사항에 해당하는 것을 <em>값</em> 이라 부릅니다. 전화번호부에 동명이인이 있을 경우 어떤 정보가 맞는 정보인지 제대로 알아낼 수 없듯이, 사전의 키는 사전에서 유일한 값이어야 합니다.</p>
<p>사전의 키는 정적 객체 (문자열 등등) 이어야 하지만, 값으로는 정적 객체나 비정적 객체 모두 사용할 수 있습니다. 이것을 간단하게 다시 말하면 사전의 키로는 단순 객체만 사용할 수 있다고 표현합니다.</p>
<p>사전을 정의할 때 키와 값의 쌍은 <code>d = {key1 : value1, key2 : value2 }</code> 와 같이 지정해 줍니다. 이 때 키와 값은 콜론으로 구분하며 각 키-값 쌍은 쉼표로 구분하고 이 모든 것을 중괄호 <code>{}</code>로 묶어 준다는 것을 기억하시기 바랍니다.</p>
<p>여기서 사전의 키-값 쌍은 자동으로 정렬되지 않으며, 파이썬 3.6 이상에서는 값이 저장된 순서대로 순서가 지정됩니다. 다르게 정렬된 값을 원한다면, 사용하기 전에 먼저 직접 정렬을 해 주어야 합니다.</p>
<p>앞으로 여러분이 사용하게 될 사전은 <code>dict</code> 라는 클래스의 인스턴스/객체입니다.</p>
<p>예제 (<code>ds_using_dict.py</code> 로 저장하세요):</p>
<pre><code class="lang-python"><span class="hljs-comment"># &apos;ab&apos; is short for &apos;a&apos;ddress&apos;b&apos;ook</span>

ab = {
    <span class="hljs-string">&apos;Swaroop&apos;</span>: <span class="hljs-string">&apos;swaroop@swaroopch.com&apos;</span>,
    <span class="hljs-string">&apos;Larry&apos;</span>: <span class="hljs-string">&apos;larry@wall.org&apos;</span>,
    <span class="hljs-string">&apos;Matsumoto&apos;</span>: <span class="hljs-string">&apos;matz@ruby-lang.org&apos;</span>,
    <span class="hljs-string">&apos;Spammer&apos;</span>: <span class="hljs-string">&apos;spammer@hotmail.com&apos;</span>
}

<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Swaroop&apos;s address is&quot;</span>, ab[<span class="hljs-string">&apos;Swaroop&apos;</span>])

<span class="hljs-comment"># Deleting a key-value pair</span>
<span class="hljs-keyword">del</span> ab[<span class="hljs-string">&apos;Spammer&apos;</span>]

<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;\nThere are {} contacts in the address-book\n&apos;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(ab)))

<span class="hljs-keyword">for</span> name, address <span class="hljs-keyword">in</span> ab.items():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Contact {} at {}&apos;</span>.<span class="hljs-built_in">format</span>(name, address))

<span class="hljs-comment"># Adding a key-value pair</span>
ab[<span class="hljs-string">&apos;Guido&apos;</span>] = <span class="hljs-string">&apos;guido@python.org&apos;</span>

<span class="hljs-keyword">if</span> <span class="hljs-string">&apos;Guido&apos;</span> <span class="hljs-keyword">in</span> ab:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\nGuido&apos;s address is&quot;</span>, ab[<span class="hljs-string">&apos;Guido&apos;</span>])
</code></pre>

<p>실행 결과:</p>
<pre><code>$ python ds_using_dict.py
Swaroop&apos;s address is swaroop@swaroopch.com

There are 3 contacts in the address-book

Contact Swaroop at swaroop@swaroopch.com
Contact Matsumoto at matz@ruby-lang.org
Contact Larry at larry@wall.org

Guido&apos;s address is guido@python.org
</code></pre>

<p><strong>동작 원리</strong></p>
<p>먼저 앞서 설명한대로 사전 <code>ab</code> 를 생성합니다. 그러면 리스트와 튜플을 설명할 때 언급했었던 인덱싱 연산자 (대괄호, []) 에 키를 지정해 주어 사전의 키-값 쌍에 접근할 수 있습니다. 간단하지요?</p>
<p>키-값 쌍도 리스트에서 했던 것과 똑같이 <code>del</code> 문으로 삭제할 수 있습니다. <code>del</code> 을 적고 사전의 이름을 적은 뒤, 인덱싱 연산자 안에 삭제하고 싶은 키를 지정해 주기만 하면 됩니다. 이 때 그 키에 해당하는 값은 지정해 줄 필요가 없습니다.</p>
<p>다음으로, 사전의 <code>items</code> 메소드를 사용하여 각 키-값 쌍에 접근합니다. 이 메소드는 키와 값 순으로 구성된 튜플들을 묶은 튜플 하나를 반환해 줍니다. 그 후 <code>for..in</code> 반복문을 사용하여 키와 값 각각을 변수 <code>name</code> 과 <code>address</code> 에 지정해 주게 하고 그 값을 출력합니다.</p>
<p>위 예제의 &apos;Guido&apos; 와 같이 인덱싱 연산자를 사용하여 새로운 키-값 쌍을 추가할 수도 있습니다.</p>
<p>또, 사전 안에 키-값 쌍이 존재하는지 <code>in</code> 연산자를 통해 확인할 수 있습니다.</p>
<p><code>dict</code> 클래스의 모든 메소드 목록을 확인하시려면 <code>help(dict)</code> 를 입력하시기 바랍니다.</p>
<blockquote>
<p><strong>키워드 인수와 사전의 관계</strong></p>
<p>함수를 호출할 때 키워드 인수를 사용해 보셨다면, 여러분은 이미 사전을 사용해 본 것입니다. 여기서 함수의 매개 변수들의 이름은 사전의 키에 대응하고, 각 매개 변수에 넘겨주는 값은 사전의 값에 대응합니다. 이러한 사전과 같은 것을 <em>심볼 테이블</em> 이라고 부릅니다.</p>
</blockquote>
<h2 id="열거형">열거형</h2>
<p>열거형들은 리스트, 튜플, 문자열 같은 것입니다. 그러면 열거형이란 무엇이고 열거형에서는 무엇이 중요할까요?</p>
<p>열거형의 주요한 두 가지 기능은 <em>멤버십 테스트</em> (<code>in</code> 과 <code>not in</code> 연산), 즉 어떤 항목이 열거형 안에 있는지 없는지 확인하는 것, 그리고 열거형 안의 특정 항목을 지정하여 가져올 수 있는 <em>인덱싱 연산</em> 입니다.</p>
<p>여기에 더하여 위에서 설명한 리스트, 튜플, 문자열의 세 가지 열거형은 <em>슬라이스</em> 연산 기능을 가지고 있는데, 이것은 열거형의 일부분을 잘라(slice) 반환하는 연산을 말하며, 다시 말해 열거형의 부분집합을 반환해 주는 연산입니다.</p>
<p>예제 (<code>ds_seq.py</code> 로 저장하세요):</p>
<pre><code class="lang-python">shoplist = [<span class="hljs-string">&apos;apple&apos;</span>, <span class="hljs-string">&apos;mango&apos;</span>, <span class="hljs-string">&apos;carrot&apos;</span>, <span class="hljs-string">&apos;banana&apos;</span>]
name = <span class="hljs-string">&apos;swaroop&apos;</span>

<span class="hljs-comment"># Indexing or &apos;Subscription&apos; operation #</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Item 0 is&apos;</span>, shoplist[<span class="hljs-number">0</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Item 1 is&apos;</span>, shoplist[<span class="hljs-number">1</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Item 2 is&apos;</span>, shoplist[<span class="hljs-number">2</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Item 3 is&apos;</span>, shoplist[<span class="hljs-number">3</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Item -1 is&apos;</span>, shoplist[-<span class="hljs-number">1</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Item -2 is&apos;</span>, shoplist[-<span class="hljs-number">2</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Character 0 is&apos;</span>, name[<span class="hljs-number">0</span>])

<span class="hljs-comment"># Slicing on a list #</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Item 1 to 3 is&apos;</span>, shoplist[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Item 2 to end is&apos;</span>, shoplist[<span class="hljs-number">2</span>:])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Item 1 to -1 is&apos;</span>, shoplist[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Item start to end is&apos;</span>, shoplist[:])

<span class="hljs-comment"># Slicing on a string #</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;characters 1 to 3 is&apos;</span>, name[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;characters 2 to end is&apos;</span>, name[<span class="hljs-number">2</span>:])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;characters 1 to -1 is&apos;</span>, name[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;characters start to end is&apos;</span>, name[:])
</code></pre>

<p>실행 결과:</p>
<pre><code>$ python ds_seq.py
Item 0 is apple
Item 1 is mango
Item 2 is carrot
Item 3 is banana
Item -1 is banana
Item -2 is carrot
Character 0 is s
Item 1 to 3 is [&apos;mango&apos;, &apos;carrot&apos;]
Item 2 to end is [&apos;carrot&apos;, &apos;banana&apos;]
Item 1 to -1 is [&apos;mango&apos;, &apos;carrot&apos;]
Item start to end is [&apos;apple&apos;, &apos;mango&apos;, &apos;carrot&apos;, &apos;banana&apos;]
characters 1 to 3 is wa
characters 2 to end is aroop
characters 1 to -1 is waroo
characters start to end is swaroop
</code></pre>

<p><strong>동작 원리</strong></p>
<p>먼저, 열거형의 각 항목을 얻어오기 위해 어떻게 인덱스 연산을 사용하는지 보겠습니다. 이를 다른 말로 <em>서브스크립션 연산</em> 이라고도 합니다. 위 예제에서 보인 것과 같이 대괄호 내에 특정 숫자를 지정해 주면, 파이썬은 열거형에서 그 위치에 있는 항목을 얻어옵니다. 여기서 파이썬은 숫자를 0부터 센다는 점을 기억하시기 바랍니다. 따라서 <code>shoplist[0]</code> 과 <code>shoplist[3]</code> 은 각각 열거형 <code>shoplist</code> 의 첫 번째와 네 번째 항목을 읽어오는 연산을 의미합니다.</p>
<p>인덱스에는 음수가 지정될 수도 있습니다. 이 경우, 열거형의 마지막부터 그 위치가 계산됩니다. 따라서, <code>shoplist[-1]</code> 은 열거형의 마지막 항목을 의미하며 <code>shoplist[-2]</code> 는 열거형의 마지막 항목 바로 뒤의 항목을 의미합니다.</p>
<p>슬라이스 연산은 대괄호 안에 콜론으로 구분한 숫자들을 입력해 주는 것입니다. 슬라이스 연산은 앞서 설명한 인덱싱 연산과 매우 비슷합니다. 이 경우 숫자는 반드시 지정해 줄 필요는 없지만 콜론은 반드시 들어가야 합니다.</p>
<p>슬라이스 연산에서 콜론 앞의 첫 번째 숫자는 슬라이스를 시작할 위치를 의미하며 콜론 뒤의 두 번째 숫자는 슬라이스를 멈출 위치를 지정합니다. 만약 첫 번째 숫자가 지정되지 않았을 경우, 파이썬은 열거형의 맨 처음부터 슬라이스를 시작합니다. 두 번째 숫자가 지정되지 않았을 경우, 파이썬은 열거형의 맨 끝에서 슬라이스를 멈춥니다. 이 때 슬라이스는 시작 위치부터 슬라이스를 <em>시작</em> 하며 <em>끝</em> 위치의 직전까지 수행됩니다. 즉, 시작 위치에 해당하는 항목은 슬라이스에 포함되나 마지막 위치에 해당하는 항목은 포함되지 않습니다.</p>
<p>따라서, <code>shoplist[1:3]</code> 은 위치 1 에 해당하는 항목부터 시작하여 위치 2 에 해당하는 항목을 포함하지만, 위치 3 에 해당하는 항목은 포함하지 않습니다. 따라서 두 개의 항목의 <em>슬라이스</em> 가 반환됩니다. 이와 비슷하게, <code>shoplist[:]</code> 는 전체 열거형의 복사본이 반환됩니다.</p>
<p>슬라이스 숫자로도 음의 위치를 지정해 줄 수 있습니다. 음수는 열거형의 마지막부터 위치를 계산하는 것을 의미합니다. 예를 들어, <code>shoplist[:-1]</code> 은 마지막 항목을 제외한 모든 항목을 포함하고 있는 슬라이스를 반환해 줍니다.</p>
<p>슬라이스 숫자에 세 번째 인수를 지정해 줄 수 있는데, 이것을 슬라이스의 <em>스텝</em> 이라 합니다 (기본값은 1 입니다):</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>shoplist = [<span class="hljs-string">&apos;apple&apos;</span>, <span class="hljs-string">&apos;mango&apos;</span>, <span class="hljs-string">&apos;carrot&apos;</span>, <span class="hljs-string">&apos;banana&apos;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>shoplist[::<span class="hljs-number">1</span>]
[<span class="hljs-string">&apos;apple&apos;</span>, <span class="hljs-string">&apos;mango&apos;</span>, <span class="hljs-string">&apos;carrot&apos;</span>, <span class="hljs-string">&apos;banana&apos;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>shoplist[::<span class="hljs-number">2</span>]
[<span class="hljs-string">&apos;apple&apos;</span>, <span class="hljs-string">&apos;carrot&apos;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>shoplist[::<span class="hljs-number">3</span>]
[<span class="hljs-string">&apos;apple&apos;</span>, <span class="hljs-string">&apos;banana&apos;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>shoplist[::-<span class="hljs-number">1</span>]
[<span class="hljs-string">&apos;banana&apos;</span>, <span class="hljs-string">&apos;carrot&apos;</span>, <span class="hljs-string">&apos;mango&apos;</span>, <span class="hljs-string">&apos;apple&apos;</span>]
</code></pre>
<p>보시는 바와 같이 스텝이 2일 경우 위치 0, 2, ...​ 에 해당되는 항목들이 반환되며 스텝이 3일 경우 0, 3, ...​ 에 해당되는 항목들이 반환됩니다.</p>
<p>파이썬 인터프리터에서 여러 가능한 슬라이스 숫자의 조합들을 시험해 보시면 그 결과를 곧바로 확인해 보실 수 있습니다. 이 모든 사항은 모든 열겨형에 적용되므로, 튜플, 리스트, 문자열의 경우 모두 동일한 방법을 사용할 수 있습니다.</p>
<h2 id="집합-set">집합 (Set)</h2>
<p>집합은 <em>정렬되지 않은</em>, 복잡하지 않은 객체들의 묶음입니다. 집합은 포함된 객체들의 순서나 중복에 상관없이 객체를 묶음 자체를 필요로 할 때 주로 사용합니다.</p>
<p>집합끼리는 멤버십 테스트를 통해 한 집합이 다른 집합의 부분집합인지 확인할 수 있으며, 두 집합의 교집합 등을 알아낼 수도 있습니다.</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>bri = <span class="hljs-built_in">set</span>([<span class="hljs-string">&apos;brazil&apos;</span>, <span class="hljs-string">&apos;russia&apos;</span>, <span class="hljs-string">&apos;india&apos;</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&apos;india&apos;</span> <span class="hljs-keyword">in</span> bri
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&apos;usa&apos;</span> <span class="hljs-keyword">in</span> bri
<span class="hljs-literal">False</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>bric = bri.copy()
<span class="hljs-meta">&gt;&gt;&gt; </span>bric.add(<span class="hljs-string">&apos;china&apos;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>bric.issuperset(bri)
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>bri.remove(<span class="hljs-string">&apos;russia&apos;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>bri &amp; bric <span class="hljs-comment"># OR bri.intersection(bric)</span>
{<span class="hljs-string">&apos;brazil&apos;</span>, <span class="hljs-string">&apos;india&apos;</span>}
</code></pre>
<p><strong>동작 원리</strong></p>
<p>이 책을 읽는 여러분들은 아마도 학교에서 기초 집합론에 대해 이미 배우셨을 것이므로 위 예제에 대해서는 딱히 설명할 것이 없습니다. 만약 아니라면, &quot;집합론&quot; 이나 &quot;벤 다이어그램&quot; 등을 검색해 보시면 파이썬에서 집합을 어떻게 활용할 수 있는지 좀 더 자세히 알 수 있을 것입니다.</p>
<h2 id="참조">참조</h2>
<p>객체를 생성하고 변수에 할당해 줄 때, 사실 실제 객체가 변수에 할당되는 것은 아닙니다! 변수에는 객체의 <em>참조</em> 가 할당됩니다. 참조란, 그 변수의 이름이 여러분의 컴퓨터 메모리 어딘가에 저장되어 있는 실제 객체의 위치를 가리키는 것을 말합니다. 이러한 것을 객체에 이름을 <em>바인딩</em> 한다고 합니다.</p>
<p>일반적으로는 참조에 대해 크게 신경 쓸 필요가 없습니다만, 이로 인해 발생하는 몇 가지 현상에 대해 알고 계실 필요가 있습니다:</p>
<p>예제 (<code>ds_reference.py</code> 로 저장하세요):</p>
<pre><code class="lang-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Simple Assignment&apos;</span>)
shoplist = [<span class="hljs-string">&apos;apple&apos;</span>, <span class="hljs-string">&apos;mango&apos;</span>, <span class="hljs-string">&apos;carrot&apos;</span>, <span class="hljs-string">&apos;banana&apos;</span>]
<span class="hljs-comment"># mylist is just another name pointing to the same object!</span>
mylist = shoplist

<span class="hljs-comment"># I purchased the first item, so I remove it from the list</span>
<span class="hljs-keyword">del</span> shoplist[<span class="hljs-number">0</span>]

<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;shoplist is&apos;</span>, shoplist)
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;mylist is&apos;</span>, mylist)
<span class="hljs-comment"># Notice that both shoplist and mylist both print</span>
<span class="hljs-comment"># the same list without the &apos;apple&apos; confirming that</span>
<span class="hljs-comment"># they point to the same object</span>

<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Copy by making a full slice&apos;</span>)
<span class="hljs-comment"># Make a copy by doing a full slice</span>
mylist = shoplist[:]
<span class="hljs-comment"># Remove first item</span>
<span class="hljs-keyword">del</span> mylist[<span class="hljs-number">0</span>]

<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;shoplist is&apos;</span>, shoplist)
<span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;mylist is&apos;</span>, mylist)
<span class="hljs-comment"># Notice that now the two lists are different</span>
</code></pre>

<p>실행 결과:</p>
<pre><code>$ python ds_reference.py
Simple Assignment
shoplist is [&apos;mango&apos;, &apos;carrot&apos;, &apos;banana&apos;]
mylist is [&apos;mango&apos;, &apos;carrot&apos;, &apos;banana&apos;]
Copy by making a full slice
shoplist is [&apos;mango&apos;, &apos;carrot&apos;, &apos;banana&apos;]
mylist is [&apos;carrot&apos;, &apos;banana&apos;]
</code></pre>

<p><strong>동작 원리</strong></p>
<p>주석에 거의 모든 설명을 달아 두었습니다.</p>
<p>리스트와 같은 어떤 열거형이나 복잡한 객체 (정수형과 같이 단순한 <em>객체</em> 들을 제외한 것들) 의 복사본을 생성하고 싶을 때에는, 슬라이스 연산자를 이용하여 복사본을 생성해야 합니다. 단순히 한 변수를 다른 변수에 할당하게 되면 두 변수는 같은 객체를 &apos;&apos;참조&apos;&apos; 하게 되며 실제 복사본이 생성되지 않습니다. 따라서 이 점을 유의하지 않으면 문제가 발생할 수 있습니다.</p>
<blockquote>
<p><strong>펄 프로그래머를 위한 주석</strong></p>
<p>이미 존재하는 리스트를 다른 변수에 할당하는 구문은 복사본을 만드는 것이 <strong>아닙니다</strong>. 열거형의 복사본을 만들려면 반드시 슬라이스 연산자를 사용하시기 바랍니다.</p>
</blockquote>
<h2 id="more-strings">문자열에 대한 좀 더 자세한 설명 </h2>
<p>앞서 문자열에 대해 이미 상세히 다루었지만, 몇 가지 더 알아두면 좋을 것들이 있습니다. 문자열도 객체이므로 여러 메소드를 가지고 있는데 이를 통해 문자열의 앞 뒤 공백을 제거한다거나 하는 일들을 할 수 있습니다. 사실 우리는 이미 문자열의 메소드를 한번 써 본 적이 있습니다... 바로 <code>format</code> 메소드입니다.</p>
<p>파이썬에서 사용되는 모든 문자열은 <code>str</code> 클래스의 객체입니다. 아래에 이 객체가 제공하는 몇가지 유용한 메소드들의 예제가 있습니다. str 클래스의 모든 메소드의 목록을 확인해 보시려면 <code>help(str)</code> 을 실행해 보시기 바랍니다.</p>
<p>예제 (<code>ds_str_methods.py</code> 로 저장하세요):</p>
<pre><code class="lang-python"><span class="hljs-comment"># This is a string object</span>
name = <span class="hljs-string">&apos;Swaroop&apos;</span>

<span class="hljs-keyword">if</span> name.startswith(<span class="hljs-string">&apos;Swa&apos;</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Yes, the string starts with &quot;Swa&quot;&apos;</span>)

<span class="hljs-keyword">if</span> <span class="hljs-string">&apos;a&apos;</span> <span class="hljs-keyword">in</span> name:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Yes, it contains the string &quot;a&quot;&apos;</span>)

<span class="hljs-keyword">if</span> name.find(<span class="hljs-string">&apos;war&apos;</span>) != -<span class="hljs-number">1</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Yes, it contains the string &quot;war&quot;&apos;</span>)

delimiter = <span class="hljs-string">&apos;_*_&apos;</span>
mylist = [<span class="hljs-string">&apos;Brazil&apos;</span>, <span class="hljs-string">&apos;Russia&apos;</span>, <span class="hljs-string">&apos;India&apos;</span>, <span class="hljs-string">&apos;China&apos;</span>]
<span class="hljs-built_in">print</span>(delimiter.join(mylist))
</code></pre>

<p>실행 결과:</p>
<pre><code>$ python ds_str_methods.py
Yes, the string starts with &quot;Swa&quot;
Yes, it contains the string &quot;a&quot;
Yes, it contains the string &quot;war&quot;
Brazil_*_Russia_*_India_*_China
</code></pre>

<p><strong>동작 원리</strong></p>
<p>여기서는 문자열이 제공하는 여러 메소드에 대해 알아보았습니다. <code>startswith</code> 메소드는 문자열이 주어진 문자열로 시작하는지 여부를 반환합니다. <code>in</code> 연산자는 문자열에 주어진 문자열이 포함되어 있는지 확인하는데 사용합니다.</p>
<p><code>find</code> 메소드는 문자열 내에 포함된 특정 문자열의 위치를 반환합니다. 이 때 주어진 문자열을 찾지 못한 경우 <code>find</code> 는 -1 을 반환합니다. 또 <code>str</code> 클래스는 <code>join</code> 이라는 유용한 메소드를 가지고 있는데, 이것은 주어진 문자열들을 해당 문자열을 구분자로 하여 결합한 하나의 큰 문자열을 만들어 반환해 주는 메소드입니다.</p>
<h2 id="요약">요약</h2>
<p>이 챕터에서는 파이썬의 여러 내장 자료구조들에 대해 상세히 알아보았습니다. 이 자료 구조들은 프로그램을 짧고 보기 쉽게 작성하는데 꼭 필요한 구성 요소들입니다.</p>
<p>이제 여러분은 파이썬의 여러 기본적인 문법에 익숙해졌을 것입니다. 이 다음부터는 실제 파이썬 프로그램을 설계하고 작성해 보도록 하겠습니다.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="modules.html" class="navigation navigation-prev " aria-label="Previous page: 모듈">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="problem_solving.html" class="navigation navigation-next " aria-label="Next page: 실생활 문제 해결">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"자료구조","level":"1.12","depth":1,"next":{"title":"실생활 문제 해결","level":"1.13","depth":1,"path":"problem_solving.md","ref":"problem_solving.md","articles":[]},"previous":{"title":"모듈","level":"1.11","depth":1,"path":"modules.md","ref":"modules.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{"authorUrl":"https://swaroopch.com/about","buyBookUrl":"https://swaroopch.com/buybook","contactUrl":"https://swaroopch.com/contact","downloadUrl":"https://github.com/swaroopch/byte-of-python/releases/latest","officialUrl":"https://python.swaroopch.com","pythonVersion":"3.6.0","sourceUrl":"https://github.com/swaroopch/byte-of-python","vimBookUrl":"https://vim.swaroopch.com/"},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"KoPubWorldDotum_Pro","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":true},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"data_structures.md","mtime":"2022-11-02T15:50:45.847Z","type":"markdown"},"gitbook":{"version":"4.0.4","time":"2022-11-02T15:51:14.995Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

